function g = sgplvmLogLikeGradients(model)

% SGPLVMLOGLIKEGRADIENTS Compute the gradients for the SGPLVM.
% FORMAT
% DESC Returns the fradients of the log likelihood with respect to
% the parameters of the sgplvm model parameters and the latent
% positions
% ARG model : sgplvm model
% RETURN g : the gradients of the latent positions ( or
% back-constraint parameters) and the parameters of the sgplvm
% model
%
% SEEALSO : sgplvmLogLikelihood, sgplvmCreate,
% modelLogLikeGradients
%
% COPYRIGHT : Neil D. Lawrence, Carl Henrik Ek, 2007

% SGPLVM

% define chunk id
gX_ind = 3;
gX_u_ind = 2;
gModel_ind = 1;

% calculate gradients for each model
g_full = cell(1,model.numModels);
for(i = 1:1:model.numModels)
  g_full{i} = cell(1,3);
  [g_full{i}{gModel_ind} g_full{i}{gX_u_ind} g_full{i}{gX_ind}] = gpLogLikeGradients(model.comp{i});
end

% prior on inducing points
for(i = 1:1:model.numModels)
  if(isfield(model.comp{i},'inducingPrior'))
    if(~isempty(model.comp{i}.inducingPrior))
      g_full{i}{gX_u_ind} = g_full{i}{gX_u_ind} + priorGradient(model.comp{i}.inducingPrior,model.comp{i}.X_u);
    end
  end
end

% handle fixInducing points
for(i = 1:1:model.numModels)
  for(j = 1:1:model.q)
    if(model.inducing_id(i,j) && model.comp{i}.fixInducing)
      g_full{i}{gX_ind}(model.comp{i}.inducingIndices,j) = g_full{i}{gX_ind}(model.comp{i}.inducingIndices,j) + g_full{i}{gX_u_ind}(:,j);
    end
  end
end

% compute gradients for the latent positions
g = [];
for(i = 1:1:model.q)  
  % prior
  gX_dyn_dim = zeros(model.N,model.q);
  gX_prior_dim = zeros(model.N,1);
  
  if(model.dynamic)
    ind = find(model.dynamic_id(:,i));
  else
    ind = [];
  end
  if(~isempty(ind))
    for(j = 1:1:length(ind))
      if(isfield(model.dynamics.comp{ind(j)},'balancing'))
	balancing = model.dynamics.comp{ind(j)}.balancing;
      else
	balancing = 1;
      end
      if(isfield(model.dynamics.comp{ind(j)},'indexOut')&&~isempty(model.dynamics.comp{ind(j)}.indexOut))
	gX_dyn_dim(:,model.dynamics.comp{ind(j)}.indexOut) = gX_dyn_dim(:,model.dynamics.comp{ind(j)}.indexOut) +...
	    balancing.*modelLatentGradients(model.dynamics.comp{ind(j)});
      else
	gX_dyn_dim = gX_dyn_dim + balancing.*modelLatentGradients(model.dynamics.comp{ind(j)});
      end
    end
    gX_dim = gX_dyn_dim(:,i);
  else
    ind = find(model.generative_id(:,i))';
    for(j = 1:1:length(ind))
      if(isfield(model.comp{ind(j)},'prior')&&~isempty(model.comp{ind(j)}.prior))
	gX_prior_dim = gX_prior_dim + priorGradient(model.comp{ind(j)}.prior,model.X(:,i));
      end
    end
    if(size(gX_prior_dim,2)==model.q)
      gX_dim = gX_prior_dim(:,i);
    else
      gX_dim = gX_prior_dim(:,1);
    end
  end
  
  % back-constraints
  ind = find(model.back_id(:,i));
  if(~isempty(ind))
    % model ind back-constrains dimension i
    g_w = modelOutputGrad(model.comp{ind}.back,model.comp{ind}.y,i);
    gX_dim = g_w(:,:)'*gX_dim;

    % add gradients from models generated by dimension i
    ind_gen = find(model.generative_id(:,i));
    for(j = 1:1:length(ind_gen))
      gX_dim = gX_dim + g_w(:,:)'*(g_full{ind_gen(j)}{gX_ind}(:,i));
    end
  else
    % dimension not back-constrained
    ind_gen = find(model.generative_id(:,i));
    for(j = 1:1:length(ind_gen))
      gX_dim = gX_dim + g_full{ind_gen(j)}{gX_ind}(:,i);
    end
  end
  g = [g gX_dim(:)'];
end

% GP's (independent part)
for(i = 1:1:model.numModels)
  switch model.comp{i}.approx
   case 'ftc'
    g = [g g_full{i}{gModel_ind}];
   case {'dtc','fitc','pitc'}
    if(model.comp{i}.fixInducing)
      g = [g g_full{i}{gModel_ind}];
    else
      if(isfield(model.comp{i},'inducingPrior') & ~isempty(model.comp{i}.inducingPrior))
	g_full{i}{gX_u_ind} = g_full{i}{gX_u_ind} + priorGradient(model.inducingPrior, model.comp{i}.X_u);
	g = [g g_full{i}{gX_u_ind}(:)' g_full{i}{gModel_ind}];
      else
	g = [g g_full{i}{gX_u_ind}(:)' g_full{i}{gModel_ind}];
      end
    end
   otherwise
    error('Unkown Approximation');
  end
end

% gradients of parameters of dynamics
if(model.dynamic)
  for(i = 1:1:model.dynamics.numModels)
    g = [g modelLogLikeGradients(model.dynamics.comp{i})];
  end
end

return